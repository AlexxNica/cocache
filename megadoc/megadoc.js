(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["megadoc"] = factory();
	else
		root["megadoc"] = factory();
})(this, function() {
return webpackJsonp_megadoc([0],{

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';var React = __webpack_require__(1);var _require =\n__webpack_require__(32),render = _require.render;var _require2 =\n__webpack_require__(167),renderToString = _require2.renderToString;\nvar Storage = __webpack_require__(172);\nvar AppState = __webpack_require__(176);\nvar K = __webpack_require__(177);\nvar App = __webpack_require__(178);var _require3 =\n__webpack_require__(187),omit = _require3.omit;\nvar CorpusAPI = __webpack_require__(232);var _require4 =\n__webpack_require__(180),OutletManager = _require4.OutletManager;\n\nfunction createMegadoc(config) {\n  console.log('megadoc: version %s', config.version);\n  var outlets = OutletManager({\n    strict: true,\n    verbose: false });\n\n\n  var corpus = CorpusAPI({\n    database: config.database || [],\n    redirect: config.redirect });\n\n\n  var megadoc = {\n    corpus: corpus };\n\n\n  Storage.register(K.CFG_COLOR_SCHEME, K.DEFAULT_SCHEME);\n  Storage.register(K.CFG_SIDEBAR_WIDTH, K.INITIAL_SIDEBAR_WIDTH);\n\n  // expose this to plugins so that we can move to a non-global version in the\n  // future\n  megadoc.outlets = outlets;\n  megadoc.outlets.define('Meta');\n  megadoc.outlets.define('LayoutWrapper');\n  megadoc.outlets.define('Layout');\n  megadoc.outlets.define('Layout::Banner');\n  megadoc.outlets.define('Layout::Content');\n  megadoc.outlets.define('Layout::Sidebar');\n  megadoc.outlets.define('Layout::NavBar');\n  megadoc.outlets.define('Layout::SidebarHeader');\n  megadoc.outlets.define('Layout::Footer');\n  megadoc.outlets.define('Inspector');\n  megadoc.outlets.define('Image');\n  megadoc.outlets.define('Link');\n  megadoc.outlets.define('Text');\n\n  __webpack_require__(236)(megadoc);\n  __webpack_require__(238)(megadoc);\n  __webpack_require__(239)(megadoc);\n  __webpack_require__(262)(megadoc);\n\n  console.log('Firing up.');\n  console.log('Loading %d external plugins.', config.plugins.length);\n\n  var pluginAPI = { corpus: corpus };\n\n  config.plugins.forEach(function (plugin) {\n    var pluginConfig = corpus.getNamespacesForPlugin(plugin.name).map(function (x) {return x.config;});\n\n    if (plugin.register) {\n      plugin.register(pluginAPI, pluginConfig);\n    }\n\n    if (plugin.outlets) {\n      plugin.outlets.forEach(function (outletSpec) {\n        if (typeof outletSpec === 'string') {\n          outlets.define(outletSpec);\n        } else\n        {\n          // TODO ?\n        }\n      });\n    }\n\n    if (plugin.outletOccupants) {\n      plugin.outletOccupants.forEach(function (occupantSpec) {\n        outlets.add(occupantSpec.name, {\n          key: occupantSpec.key || 'default',\n          component: occupantSpec.component });\n\n      });\n    }\n  });\n\n  var appConfig = omit(config, [\n  'database',\n  'plugins',\n  'startingDocumentUID',\n  'startingDocumentHref',\n  'pluginConfigs']);\n\n\n  var appState = AppState(config);\n\n  return { appConfig: appConfig, appState: appState, outlets: outlets, corpus: corpus };\n}\n\nexports.createClient = function (config) {\n  var megadoc = createMegadoc(config);\n\n  return {\n    render: function render(href, done) {\n      done(null, renderToString(\n      React.createElement(App, {\n        config: megadoc.appConfig,\n        appState: megadoc.appState,\n        corpus: megadoc.corpus,\n        outletManager: megadoc.outlets,\n        location: {\n          protocol: 'file:',\n          origin: \"file://\",\n          pathname: href.replace(/^#/, ''),\n          hash: '' } })));\n\n\n\n    } };\n\n};\n\nexports.startApp = function (config) {\n  var megadoc = createMegadoc(config);\n  var mountPath = MountPath(\n  megadoc.corpus.get(config.startingDocumentUID),\n  config.startingDocumentHref);\n\n\n  console.log('Mount path = \"%s\".', mountPath);\n\n  render(\n  React.createElement(App, {\n    config: Object.assign({}, megadoc.appConfig, { mountPath: mountPath }),\n    appState: megadoc.appState,\n    corpus: megadoc.corpus,\n    outletManager: megadoc.outlets,\n    location: window.location }),\n\n  document.querySelector('#__app__'));\n\n};\n\n// const megadoc = window.megadoc = createMegadoc(config);\n\n// module.exports = megadoc;\n\nfunction MountPath(currentDocument, startingHref) {\n  if (currentDocument) {\n    return location.pathname.replace(currentDocument.meta.href, '');\n  } else\n  if (startingHref) {\n    return location.pathname.replace(startingHref, '');\n  } else\n  {\n    return '';\n  }\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/ui/index.js\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/ui/index.js?");

/***/ },

/***/ 167:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nmodule.exports = __webpack_require__(168);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/~/react-dom/server.js\n ** module id = 167\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/~/react-dom/server.js?");

/***/ },

/***/ 168:
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactDOMServer\n */\n\n'use strict';\n\nvar ReactDefaultInjection = __webpack_require__(37);\nvar ReactServerRendering = __webpack_require__(169);\nvar ReactVersion = __webpack_require__(30);\n\nReactDefaultInjection.inject();\n\nvar ReactDOMServer = {\n  renderToString: ReactServerRendering.renderToString,\n  renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,\n  version: ReactVersion\n};\n\nmodule.exports = ReactDOMServer;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/~/react/lib/ReactDOMServer.js\n ** module id = 168\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/~/react/lib/ReactDOMServer.js?");

/***/ },

/***/ 169:
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactServerRendering\n */\n'use strict';\n\nvar ReactDOMContainerInfo = __webpack_require__(158);\nvar ReactDefaultBatchingStrategy = __webpack_require__(129);\nvar ReactElement = __webpack_require__(7);\nvar ReactMarkupChecksum = __webpack_require__(160);\nvar ReactServerBatchingStrategy = __webpack_require__(170);\nvar ReactServerRenderingTransaction = __webpack_require__(171);\nvar ReactUpdates = __webpack_require__(54);\n\nvar emptyObject = __webpack_require__(20);\nvar instantiateReactComponent = __webpack_require__(115);\nvar invariant = __webpack_require__(6);\n\n/**\n * @param {ReactElement} element\n * @return {string} the HTML markup\n */\nfunction renderToStringImpl(element, makeStaticMarkup) {\n  var transaction;\n  try {\n    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);\n\n    transaction = ReactServerRenderingTransaction.getPooled(makeStaticMarkup);\n\n    return transaction.perform(function () {\n      var componentInstance = instantiateReactComponent(element);\n      var markup = componentInstance.mountComponent(transaction, null, ReactDOMContainerInfo(), emptyObject);\n      if (!makeStaticMarkup) {\n        markup = ReactMarkupChecksum.addChecksumToMarkup(markup);\n      }\n      return markup;\n    }, null);\n  } finally {\n    ReactServerRenderingTransaction.release(transaction);\n    // Revert to the DOM batching strategy since these two renderers\n    // currently share these stateful modules.\n    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);\n  }\n}\n\nfunction renderToString(element) {\n  !ReactElement.isValidElement(element) ?  true ? invariant(false, 'renderToString(): You must pass a valid ReactElement.') : invariant(false) : void 0;\n  return renderToStringImpl(element, false);\n}\n\nfunction renderToStaticMarkup(element) {\n  !ReactElement.isValidElement(element) ?  true ? invariant(false, 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(false) : void 0;\n  return renderToStringImpl(element, true);\n}\n\nmodule.exports = {\n  renderToString: renderToString,\n  renderToStaticMarkup: renderToStaticMarkup\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/~/react/lib/ReactServerRendering.js\n ** module id = 169\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/~/react/lib/ReactServerRendering.js?");

/***/ },

/***/ 170:
/***/ function(module, exports) {

	eval("/**\n * Copyright 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactServerBatchingStrategy\n */\n\n'use strict';\n\nvar ReactServerBatchingStrategy = {\n  isBatchingUpdates: false,\n  batchedUpdates: function (callback) {\n    // Don't do anything here. During the server rendering we don't want to\n    // schedule any updates. We will simply ignore them.\n  }\n};\n\nmodule.exports = ReactServerBatchingStrategy;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/~/react/lib/ReactServerBatchingStrategy.js\n ** module id = 170\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/~/react/lib/ReactServerBatchingStrategy.js?");

/***/ },

/***/ 171:
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * Copyright 2014-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactServerRenderingTransaction\n */\n\n'use strict';\n\nvar _assign = __webpack_require__(3);\n\nvar PooledClass = __webpack_require__(5);\nvar Transaction = __webpack_require__(61);\n\n/**\n * Executed within the scope of the `Transaction` instance. Consider these as\n * being member methods, but with an implied ordering while being isolated from\n * each other.\n */\nvar TRANSACTION_WRAPPERS = [];\n\nvar noopCallbackQueue = {\n  enqueue: function () {}\n};\n\n/**\n * @class ReactServerRenderingTransaction\n * @param {boolean} renderToStaticMarkup\n */\nfunction ReactServerRenderingTransaction(renderToStaticMarkup) {\n  this.reinitializeTransaction();\n  this.renderToStaticMarkup = renderToStaticMarkup;\n  this.useCreateElement = false;\n}\n\nvar Mixin = {\n  /**\n   * @see Transaction\n   * @abstract\n   * @final\n   * @return {array} Empty list of operation wrap procedures.\n   */\n  getTransactionWrappers: function () {\n    return TRANSACTION_WRAPPERS;\n  },\n\n  /**\n   * @return {object} The queue to collect `onDOMReady` callbacks with.\n   */\n  getReactMountReady: function () {\n    return noopCallbackQueue;\n  },\n\n  /**\n   * `PooledClass` looks for this, and will invoke this before allowing this\n   * instance to be reused.\n   */\n  destructor: function () {}\n};\n\n_assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);\n\nPooledClass.addPoolingTo(ReactServerRenderingTransaction);\n\nmodule.exports = ReactServerRenderingTransaction;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/~/react/lib/ReactServerRenderingTransaction.js\n ** module id = 171\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/~/react/lib/ReactServerRenderingTransaction.js?");

/***/ },

/***/ 178:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';var React = __webpack_require__(1);\nvar Root = __webpack_require__(179);\nvar DocumentURI = __webpack_require__(208);\nvar DocumentResolver = __webpack_require__(231);var _require =\n__webpack_require__(180),OutletProvider = _require.OutletProvider;var\n\nPropTypes = React.PropTypes;\n\nvar App = React.createClass({ displayName: 'App',\n  propTypes: {\n    appState: PropTypes.object.isRequired,\n    config: PropTypes.object.isRequired,\n    corpus: PropTypes.object.isRequired,\n    location: __webpack_require__(235).isRequired },\n\n\n  childContextTypes: {\n    appState: PropTypes.object,\n    corpus: PropTypes.object,\n    documentResolver: PropTypes.instanceOf(DocumentResolver),\n    documentURI: PropTypes.instanceOf(DocumentURI) },\n\n\n  getInitialState: function getInitialState() {\n    return {\n      hashDisabled: true };\n\n  },\n\n  getChildContext: function getChildContext() {\n    return {\n      appState: this.props.appState,\n      corpus: this.props.corpus,\n      documentURI: this.documentURI,\n      documentResolver: this.documentResolver };\n\n  },\n\n  componentWillMount: function componentWillMount() {var\n    config = this.props.config;\n\n    this.documentURI = new DocumentURI({\n      mountPath: this.props.location.protocol === 'file:' ? config.mountPath : null,\n      extension: config.emittedFileExtension });\n\n\n    this.documentResolver = new DocumentResolver({\n      config: config,\n      corpus: this.props.corpus,\n      documentURI: this.documentURI });\n\n\n    var pathname = this.props.location.pathname.replace(config.mountPath, '');\n    var redirect = config.redirect[pathname];\n\n    var locationAPI = void 0;\n\n    if (config.layoutOptions && config.layoutOptions.singlePageMode) {\n      locationAPI = HashLocation;\n    } else\n    if (this.props.location.protocol === 'file:') {\n      locationAPI = FileLocation;\n    } else\n    if (this.props.location.protocol.match(/^http:/)) {\n      locationAPI = HistoryLocation;\n    }\n\n    this.locationAPI = locationAPI({\n      mountPath: config.mountPath,\n      location: this.props.location,\n      onChange: this.reload });\n\n\n    this.locationAPI.start();\n\n    if (redirect) {\n      this.locationAPI.transitionTo(redirect);\n    }\n  },\n\n  componentDidMount: function componentDidMount() {\n    // this is to avoid discrepancy with the server-rendered version since it\n    // will not have a hash fragment and the client would (hash fragment may\n    // change the UI if it's pointing to a DocumentEntity)\n    this.setState({ hashDisabled: false });\n  },\n\n  componentWillUnmount: function componentWillUnmount() {\n    this.locationAPI.stop();\n  },\n\n  render: function render() {var\n    location = this.props.location;\n\n    return (\n      React.createElement(OutletProvider, { outletManager: this.props.outletManager },\n        React.createElement(Root, {\n          onNavigate: this.navigate,\n          onRefreshScroll: this.locationAPI.refreshScroll,\n          config: this.props.config,\n          corpus: this.props.corpus,\n          appState: this.props.appState,\n          location: {\n            pathname: this.documentURI.normalize(location.pathname),\n            hash: this.state.hashDisabled ? '' : location.hash,\n            origin: location.origin,\n            protocol: location.protocol } })));\n\n\n\n\n  },\n\n  reload: function reload() {\n    console.debug('App: forcing update.');\n\n    this.forceUpdate();\n  },\n\n  navigate: function navigate(e, domNode) {\n    if (isLeftClickEvent(e) && !isModifiedEvent(e)) {\n      var href = domNode.href.replace(location.origin, '');\n\n      if (this.locationAPI.transitionTo(href)) {\n        e.stopPropagation();\n        e.preventDefault();\n      }\n    }\n  } });\n\n\nmodule.exports = App;\n\n/**\n                       * Requirements:\n                       *\n                       * - use relative links everywhere\n                       *\n                       * ## MPM and the `http://` protocol\n                       *\n                       * - use the History API\n                       * - use location.pathname to point to documents\n                       * - use location.hash to point to entities\n                       *\n                       * ## MPM and the `file://` protocol\n                       *\n                       * - use no location API, navigate using regular links\n                       * - use mountpoint to figure out the proper pathname\n                       * - use location.pathname to point to documents\n                       * - use location.hash to point to entities\n                       *\n                       * ## SPM and any protocol\n                       *\n                       * - use hash location\n                       * - use location.hash to point to both documents and entities\n                       */\nfunction HistoryLocation(options) {var _window =\n  window,history = _window.history;\n  var emitChange = options.onChange;\n  var exports = {\n    start: function start() {\n      window.addEventListener('hashchange', refreshScroll);\n      window.addEventListener('popstate', emitChange);\n\n      if (options.location.pathname === '/') {\n        exports.transitionTo('/index.html');\n      }\n    },\n\n    transitionTo: function transitionTo(pathname) {\n      history.pushState(null, null, pathname);\n\n      emitChange();\n\n      return true;\n    },\n\n    refreshScroll: refreshScroll,\n\n    stop: function stop() {\n      window.removeEventListener('popstate', emitChange);\n      window.removeEventListener('hashchange', refreshScroll);\n    } };\n\n\n  return exports;\n\n  // force the browser to (re)scroll to the proper location\n  function refreshScroll() {var\n    location = options.location;\n    var originalLocation = location.hash;\n\n    if (originalLocation && originalLocation.length > 0) {\n      location.replace(originalLocation);\n    }\n  }\n}\n\nfunction HashLocation(options) {\n  var emitChange = options.onChange;\n\n  return {\n    start: function start() {\n      window.addEventListener('hashchange', emitChange);\n    },\n    transitionTo: function transitionTo() {},\n    refreshScroll: function refreshScroll() {},\n    stop: function stop() {\n      window.removeEventListener('hashchange', emitChange);\n    } };\n\n}\n\nfunction FileLocation(options) {\n  var emitChange = options.onChange;\n\n  return {\n    start: function start() {\n      window.addEventListener('hashchange', emitChange);\n    },\n    transitionTo: function transitionTo(pathname) {\n      // hash change, do nothing:\n      if (pathname[0] === '#') {\n        return;\n      } else\n      if (pathname.indexOf(options.mountPath) === 0) {\n        location.href = pathname;\n      } else\n      {\n        location.href = [options.mountPath, pathname].join('/').replace(/\\/+/g, '/');\n      }\n    },\n    refreshScroll: function refreshScroll() {},\n    stop: function stop() {\n      window.removeEventListener('hashchange', emitChange);\n    } };\n\n}\n\nfunction isLeftClickEvent(event) {\n  return event.button === 0;\n}\n\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/ui/screens/App.js\n ** module id = 178\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/ui/screens/App.js?");

/***/ },

/***/ 179:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {return typeof obj;} : function (obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};var _extends = Object.assign || function (target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i];for (var key in source) {if (Object.prototype.hasOwnProperty.call(source, key)) {target[key] = source[key];}}}return target;};var React = __webpack_require__(1);var _require =\n__webpack_require__(180),Outlet = _require.Outlet;\nvar Storage = __webpack_require__(172);\nvar SpotlightManager = __webpack_require__(185);\nvar Inspector = __webpack_require__(209);\nvar Layout = __webpack_require__(211);\nvar ScrollSpy = __webpack_require__(229);\nvar DocumentResolver = __webpack_require__(231);\nvar DocumentURI = __webpack_require__(208);\nvar LayoutTemplate = __webpack_require__(234);\nvar ErrorMessage = __webpack_require__(224);var _React$PropTypes =\nReact.PropTypes,object = _React$PropTypes.object,func = _React$PropTypes.func;\n\nvar Root = React.createClass({ displayName: 'Root',\n  childContextTypes: {\n    config: object,\n    location: __webpack_require__(235),\n    navigate: func },\n\n\n  propTypes: {\n    appState: object.isRequired,\n    config: object,\n    corpus: object.isRequired,\n    location: __webpack_require__(235),\n    onNavigate: func,\n    onRefreshScroll: func },\n\n\n  contextTypes: {\n    documentURI: React.PropTypes.instanceOf(DocumentURI).isRequired,\n    documentResolver: React.PropTypes.instanceOf(DocumentResolver).isRequired },\n\n\n  getChildContext: function getChildContext() {\n    return {\n      location: this.props.location,\n      config: this.props.config,\n      navigate: this.props.onNavigate };\n\n  },\n\n  componentWillMount: function componentWillMount() {\n    this.realizeTemplate = LayoutTemplate(this.props.corpus, this.props.config);\n  },\n\n  componentDidMount: function componentDidMount() {\n    Storage.on('change', this.reload);\n    this.props.appState.on('change', this.reload);\n\n    window.addEventListener('click', this.handleInternalLink, false);\n  },\n\n  componentDidUpdate: function componentDidUpdate(prevProps) {\n    if (prevProps.location.hash !== this.props.location.hash) {\n      console.debug('Hash has changed from \"%s\" to \"%s\" - forcing refresh!', prevProps.location.hash, this.props.location.hash);\n      this.props.onRefreshScroll();\n    }\n  },\n\n  componentWillUnmount: function componentWillUnmount() {\n    this.realizeTemplate = null;\n\n    window.removeEventListener('click', this.handleInternalLink, false);\n\n    this.props.appState.off('change', this.reload);\n    Storage.off('change', this.reload);\n  },\n\n  render: function render() {var\n    config = this.props.config;\n    var pathname = this.getPathName();\n    var scope = void 0;\n    var template = void 0;\n\n    if (!this.props.appState.inSinglePageMode()) {\n      scope = this.resolveCurrentDocument();\n\n      if (!scope) {\n        return this.renderInternalError();\n      }\n    }\n\n    template = this.realizeTemplate(scope, this.getPathName());\n\n    return (\n      React.createElement(Outlet, { name: 'LayoutWrapper', forwardChildren: true },\n        React.createElement(Outlet, { name: 'Meta' }),\n\n        config.tooltipPreviews &&\n        React.createElement(Inspector, {\n          corpus: this.props.corpus,\n          inSinglePageMode: config.layoutOptions && config.layoutOptions.singlePageMode }),\n\n\n        config.spotlight &&\n        React.createElement(SpotlightManager, {\n          corpus: this.props.corpus,\n          active: this.props.appState.isSpotlightOpen(),\n          onOpen: this.props.appState.openSpotlight,\n          onClose: this.props.appState.closeSpotlight,\n          documentNode: scope && scope.documentNode,\n          pathname: pathname }),\n\n\n\n        config.scrollSpying &&\n        React.createElement(ScrollSpy, null),\n\n\n        React.createElement(Layout, _extends({},\n        config.layoutOptions, {\n          pathname: pathname,\n          scope: scope,\n          template: template }))));\n\n\n\n  },\n\n  renderInternalError: function renderInternalError() {\n    return (\n      React.createElement(ErrorMessage, { style: { width: '50vw', margin: '10vh auto 0 auto' } },\n        React.createElement('p', null, 'There was no document found at this URL. This most likely indicates a configuration error. Please check and try again.'),\n\n\n\n        React.createElement('p', null, 'Debugging information:'),\n\n        React.createElement('pre', null, 'Corpus size: ',\n          this.props.corpus.length,\n          \"\\n\", 'Location: ',\n          JSON.stringify(this.getLocation(), null, 2))));\n\n\n\n  },\n\n  reload: function reload() {\n    console.debug('Root: updating');\n    this.forceUpdate();\n  },\n\n  handleInternalLink: function handleInternalLink(e) {\n    var node = e.target;\n\n    if ((node.tagName === 'A' || node.tagName === 'a') && isInternalLink(node)) {\n      this.props.onNavigate(e, {\n        href: node.getAttribute('href') });\n\n    }\n  },\n\n  resolveCurrentDocument: function resolveCurrentDocument() {\n    return this.context.documentResolver.resolveFromLocation(this.getLocation(), this.props.config);\n  },\n\n  getPathName: function getPathName() {\n    return this.context.documentResolver.getProtocolAgnosticPathName(\n    this.getLocation(),\n    this.context.documentURI);\n\n  },\n\n  getLocation: function getLocation() {\n    return this.props.location;\n  } });\n\n\nmodule.exports = Root;\n\nfunction isInternalLink(node) {\n  var href = node.href;\n\n  if (href && (typeof href === 'undefined' ? 'undefined' : _typeof(href)) === 'object') {\n    // SVG\n    if (node.className.baseVal.indexOf('mega-link--internal') > -1) {\n      return href.baseVal;\n    }\n  } else\n  {\n    return href && href.indexOf(location.origin) === 0;\n  }\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/ui/screens/Root.js\n ** module id = 179\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/ui/screens/Root.js?");

/***/ },

/***/ 185:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';var React = __webpack_require__(1);var _require =\n__webpack_require__(32),findDOMNode = _require.findDOMNode;\nvar Spotlight = __webpack_require__(186);\nvar contains = __webpack_require__(205);var _require2 =\n__webpack_require__(177),KC_ESCAPE = _require2.KC_ESCAPE;var _React$PropTypes =\nReact.PropTypes,bool = _React$PropTypes.bool,func = _React$PropTypes.func,object = _React$PropTypes.object,string = _React$PropTypes.string;\nvar DocumentURI = __webpack_require__(208);\n\nvar SpotlightManager = React.createClass({ displayName: 'SpotlightManager',\n  propTypes: {\n    active: bool.isRequired,\n    onOpen: func.isRequired,\n    onClose: func.isRequired,\n    documentNode: object,\n    pathname: string.isRequired },\n\n\n  contextTypes: {\n    documentURI: React.PropTypes.instanceOf(DocumentURI).isRequired },\n\n\n  getInitialState: function getInitialState() {\n    return {\n      openedInSymbolMode: false };\n\n  },\n\n  componentDidMount: function componentDidMount() {\n    window.addEventListener('keydown', this.handleGlobalKeybindings, true);\n\n    if (this.props.active) {\n      this.closeSpotlightOnExternalClicks();\n    }\n  },\n\n  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {\n    if (!prevProps.active && this.props.active) {\n      this.closeSpotlightOnExternalClicks();\n    } else\n    if (prevProps.active && !this.props.active) {\n      this.stopClosingSpotlightOnExternalClicks();\n    }\n\n    if (prevState.openedInSymbolMode) {\n      this.setState({ openedInSymbolMode: false });\n    }\n  },\n\n  componentWillUnmount: function componentWillUnmount() {\n    window.removeEventListener('keydown', this.handleGlobalKeybindings, true);\n  },\n\n  render: function render() {var\n    corpus = this.props.corpus;\n\n    if (this.props.active) {\n      var symbols = this.props.documentNode ?\n      getSymbolsForDocument(corpus, this.props.documentNode) :\n      getSymbolsForDocumentByURI(corpus, this.context.documentURI.normalize(this.props.pathname));\n\n\n      return (\n        React.createElement(Spotlight, {\n          startInSymbolMode: this.state.openedInSymbolMode,\n          corpus: corpus.getDocumentSearchIndex(),\n          symbols: symbols,\n          onActivate: this.closeSpotlight }));\n\n\n    } else\n    {\n      return null;\n    }\n  },\n\n  openSpotlight: function openSpotlight() {\n    this.props.onOpen();\n  },\n\n  closeSpotlight: function closeSpotlight() {\n    this.props.onClose();\n  },\n\n  handleGlobalKeybindings: function handleGlobalKeybindings(e) {var _this = this;\n    var keyName = String.fromCharCode(e.which).toLowerCase();\n    var superKey = e.ctrlKey || e.metaKey;\n\n    if (keyName === 'k' && superKey) {\n      e.preventDefault();\n\n      if (this.props.active) {\n        this.closeSpotlight();\n      } else\n      {\n        this.openSpotlight();\n      }\n    } else\n    if (e.which === 190 /*.*/ && superKey && !this.props.active) {\n      e.preventDefault();\n\n      this.setState({ openedInSymbolMode: true }, function () {\n        _this.openSpotlight();\n      });\n    } else\n    if (e.which === KC_ESCAPE) {\n      e.preventDefault();\n\n      this.closeSpotlight();\n    }\n  },\n\n  closeSpotlightOnExternalClicks: function closeSpotlightOnExternalClicks() {\n    window.addEventListener('click', this.doCloseSpotlightOnExternalClicks, false);\n  },\n\n  stopClosingSpotlightOnExternalClicks: function stopClosingSpotlightOnExternalClicks() {\n    window.removeEventListener('click', this.doCloseSpotlightOnExternalClicks, false);\n  },\n\n  doCloseSpotlightOnExternalClicks: function doCloseSpotlightOnExternalClicks(e) {\n    if (contains(e.target, findDOMNode(this))) {\n      this.closeSpotlight();\n    }\n  } });\n\n\nfunction getSymbolsForDocument(corpus, documentNode) {\n  return corpus.getDocumentEntitySearchIndex(documentNode.uid);\n}\n\nfunction getSymbolsForDocumentByURI(corpus, uri) {\n  var documentNode = corpus.getByURI(uri);\n\n  if (documentNode) {\n    return getSymbolsForDocument(corpus, documentNode);\n  }\n}\n\nmodule.exports = SpotlightManager;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/ui/components/SpotlightManager.js\n ** module id = 185\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/ui/components/SpotlightManager.js?");

/***/ },

/***/ 186:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';var React = __webpack_require__(1);var _require =\n__webpack_require__(32),findDOMNode = _require.findDOMNode;var _require2 =\n__webpack_require__(187),debounce = _require2.debounce;\nvar TokenSearcher = __webpack_require__(189);\nvar Link = __webpack_require__(197);\nvar classSet = __webpack_require__(199);var _React$PropTypes =\nReact.PropTypes,func = _React$PropTypes.func,arrayOf = _React$PropTypes.arrayOf,shape = _React$PropTypes.shape,string = _React$PropTypes.string,bool = _React$PropTypes.bool;\nvar hasScrollIntoViewIfNeeded = typeof window.Element.prototype.scrollIntoViewIfNeeded === 'function';\n\nvar TokensPropType = arrayOf(shape({\n  $1: string,\n  $2: string,\n  $3: string,\n  link: shape({\n    href: string }) }));\n\n\n\nvar Spotlight = React.createClass({ displayName: 'Spotlight',\n  statics: {\n    MAX_RESULTS: 15 },\n\n\n  propTypes: {\n    onActivate: func, // emitted when a document has been selected and jumped to\n    corpus: TokensPropType,\n    symbols: TokensPropType,\n    startInSymbolMode: bool },\n\n\n  getInitialState: function getInitialState() {\n    return {\n      results: [],\n      lastSearchTerm: '',\n      cursor: 0 };\n\n  },\n\n  componentWillMount: function componentWillMount() {\n    this.debouncedSearch = debounce(this.search, 13);\n    this.corpusSearcher = TokenSearcher(this.props.corpus);\n    this.buildSymbolSearcher(this.props.symbols);\n  },\n\n  componentDidMount: function componentDidMount() {\n    if (this.props.startInSymbolMode) {\n      var node = findDOMNode(this.refs.editingWidget);\n\n      node.value = '@';\n      this.search('@');\n    }\n  },\n\n  componentWillUpdate: function componentWillUpdate(nextProps) {\n    if (nextProps.symbols !== this.props.symbols) {\n      this.buildSymbolSearcher(nextProps.symbols);\n    }\n  },\n\n  componentDidUpdate: function componentDidUpdate(prevProps, prevState) {\n    if (prevState.cursor !== this.state.cursor) {\n      this.scrollSelectedIntoView();\n    }\n  },\n\n  render: function render() {var\n    results = this.state.results;\n    var inSymbolMode = this.state.lastSearchTerm.match(/^@/);\n    var showAllSymbols = this.state.lastSearchTerm === '@';\n    var displayableResults = this.getNavigatableResults();\n\n    return (\n      React.createElement('div', { className: 'spotlight__wrapper' },\n        React.createElement('div', { className: 'spotlight' },\n          React.createElement('div', { className: 'spotlight__help' },\n            React.createElement('span', null,\n              inSymbolMode ? 'Jump to a symbol' : 'Jump to a document'),\n\n\n            React.createElement('div', { className: 'float--right' },\n              React.createElement('div', { className: 'spotlight__help-entry' },\n                React.createElement('strong', null, 'tab'), ' or ', React.createElement('strong', null, '\\u2191'), React.createElement('strong', null, '\\u2193'), ' to navigate'),\n\n\n              ' ',\n\n              React.createElement('div', { className: 'spotlight__help-entry' },\n                React.createElement('strong', null, '\\u21B5'), ' to select'),\n\n\n              ' ',\n\n              React.createElement('div', { className: 'spotlight__help-entry' },\n                React.createElement('strong', null, 'esc'), ' to dismiss'))),\n\n\n\n\n          React.createElement('input', {\n            autoFocus: true,\n            type: 'text',\n            onChange: this.proxyToDebouncedSearch,\n            className: 'spotlight__input',\n            onKeyDown: this.navigate,\n            ref: 'editingWidget' }),\n\n\n          React.createElement('ul', { className: 'spotlight__results', ref: 'scrollableWidget' },\n            !showAllSymbols && results.length === 0 && this.state.lastSearchTerm.length > 0 &&\n            React.createElement('li', { className: 'spotlight__result' }, 'Nothing matched your query. \\uD83D\\uDE1E'),\n\n\n\n\n            showAllSymbols && (this.props.symbols || []).length === 0 &&\n            React.createElement('li', { className: 'spotlight__result' }, 'No symbols were found for this document. \\uD83D\\uDE1E'),\n\n\n\n\n            displayableResults.map(this.renderResult)))));\n\n\n\n\n  },\n\n  getNavigatableResults: function getNavigatableResults() {\n    if (this.state.lastSearchTerm === '@') {\n      return this.props.symbols || [];\n    } else\n    {\n      return this.state.results;\n    }\n  },\n\n  renderResult: function renderResult(token, index) {\n    var href = token.link.href;\n    var text = token.$1;\n\n    return (\n      React.createElement('li', {\n          key: href + (token.link.anchor || ''),\n          className: classSet({\n            \"spotlight__result\": true,\n            \"spotlight__result--active\": this.state.cursor === index }) },\n\n\n        React.createElement(Link, { href: href, anchor: token.link.anchor, ref: 'link__' + index, onClick: this.props.onActivate },\n          React.createElement('span', { dangerouslySetInnerHTML: { __html:\n              text.replace(/^(\\s+)/, function (x) {return Array(x.length + 1).join('&nbsp;&nbsp;');}) } }), ' ',\n          token.link.context &&\n          React.createElement('em', { className: 'spotlight__result-context' },\n            token.link.context))));\n\n\n\n\n\n  },\n\n  buildSymbolSearcher: function buildSymbolSearcher(symbols) {\n    this.symbolSearcher = symbols ? TokenSearcher(symbols) : null;\n  },\n\n  proxyToDebouncedSearch: function proxyToDebouncedSearch(e) {\n    this.debouncedSearch(e.target.value);\n  },\n\n  search: function search(term) {\n    var results = term.match(/^@/) && this.symbolSearcher ?\n    this.symbolSearcher.search(term.slice(1)) :\n    this.corpusSearcher.search(term).slice(0, Spotlight.MAX_RESULTS);\n\n\n    this.setState({\n      cursor: 0,\n      lastSearchTerm: term,\n      results: results });\n\n  },\n\n  navigate: function navigate(e) {var\n    keyCode = e.keyCode;\n    var superKey = e.ctrlKey || e.metaKey;\n\n    if (keyCode === 40) {// KC_DOWN_ARROW\n      e.preventDefault();\n      this.selectNext();\n    } else\n    if (keyCode === 38) {// KC_UP_ARROW\n      e.preventDefault();\n      this.selectPrev();\n    } else\n    if (keyCode === 35 && superKey) {// KC_END\n      e.preventDefault();\n      this.selectLast();\n    } else\n    if (keyCode === 36 && superKey) {// KC_HOME\n      e.preventDefault();\n      this.selectFirst();\n    } else\n    if (keyCode === 9) {// KC_TAB\n      e.preventDefault();\n\n      if (e.shiftKey) {\n        this.selectPrev();\n      } else\n      {\n        this.selectNext();\n      }\n    } else\n    if (keyCode === 13) {// KC_RETURN\n      e.preventDefault();\n      this.activateSelected();\n\n      if (this.props.onActivate) {\n        this.props.onActivate();\n      }\n    }\n  },\n\n  selectFirst: function selectFirst() {\n    var results = this.getNavigatableResults();\n\n    if (results.length) {\n      this.updateCursor(0);\n    }\n  },\n\n  selectNext: function selectNext() {\n    var results = this.getNavigatableResults();\n\n    if (results.length) {\n      this.updateCursor(this.state.cursor < results.length - 1 ?\n      this.state.cursor + 1 :\n      0);\n\n    }\n  },\n\n  selectPrev: function selectPrev() {\n    var results = this.getNavigatableResults();\n\n    if (results.length) {\n      this.updateCursor(this.state.cursor > 0 ?\n      this.state.cursor - 1 :\n      results.length - 1);\n\n    }\n  },\n\n  selectLast: function selectLast() {\n    var results = this.getNavigatableResults();\n\n    if (results.length) {\n      this.updateCursor(results.length - 1);\n    }\n  },\n\n  updateCursor: function updateCursor(newCursor) {\n    if (this.state.cursor !== newCursor) {\n      this.setState({ cursor: newCursor });\n    }\n  },\n\n  scrollSelectedIntoView: function scrollSelectedIntoView() {\n    if (hasScrollIntoViewIfNeeded) {\n      var selectedNode = this.getSelectedDOMNode();\n\n      if (selectedNode) {\n        selectedNode.scrollIntoViewIfNeeded();\n      }\n    }\n  },\n\n  activateSelected: function activateSelected() {\n    var selectedNode = this.getSelectedDOMNode();\n\n    if (selectedNode) {\n      selectedNode.click();\n    }\n  },\n\n  getSelectedDOMNode: function getSelectedDOMNode() {\n    return findDOMNode(this.refs['link__' + this.state.cursor]);\n  } });\n\n\n// function highlight(term, matches) {\n//   if (matches.length === 0) {\n//     return term;\n//   }\n\n//   return matches.reduce(function(buffer, match, index) {\n//     return buffer.concat([\n//       // any leading characters that were not matched:\n//       index === 0 && match[0] > 0 && { text: term.slice(0, match[0]) },\n\n//       // the substring between the last match and this one:\n//       index > 0 && matches[index-1][1] < match[0] &&\n//         { text: term.slice(matches[index-1][1]+1, match[0]) },\n\n//       // the match body\n//       { text: term.slice(match[0], match[1] + 1), highlighted: true },\n\n//       // add any trailing, non-matched characters\n//       index === matches.length - 1 && match[1] < term.length &&\n//         { text: term.slice(match[1]+1) },\n//     ]);\n//   }, []).filter(x => !!x).map(function(entry, index) {\n//     return (\n//       <span\n//         key={`${entry.text}:${index}`}\n//         className={entry.highlighted ? \"spotlight__highlighted-term\" : undefined}\n//       >\n//         {entry.text}\n//       </span>\n//     );\n//   });\n// }\n\nmodule.exports = Spotlight;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/ui/components/Spotlight.js\n ** module id = 186\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/ui/components/Spotlight.js?");

/***/ },

/***/ 209:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';var React = __webpack_require__(1);var _require =\n__webpack_require__(32),findDOMNode = _require.findDOMNode;\nvar domContains = __webpack_require__(205);\nvar Tooltip = __webpack_require__(210);var _require2 =\n__webpack_require__(180),Outlet = _require2.Outlet,OutletRenderer = _require2.OutletRenderer;var _require3 =\n__webpack_require__(187),debounce = _require3.debounce;var\nPropTypes = React.PropTypes;\n\nvar Inspector = React.createClass({ displayName: 'Inspector',\n  propTypes: {\n    inSinglePageMode: PropTypes.bool,\n    isOutletOccupied: PropTypes.func.isRequired },\n\n\n  getInitialState: function getInitialState() {\n    return {\n      element: null };\n\n  },\n\n  componentDidMount: function componentDidMount() {\n    this.debouncedShowTooltip = debounce(this.showTooltip, 10);\n    this.debouncedHideTooltip = debounce(this.hideTooltip, 10);\n\n    window.addEventListener('mouseover', this.debouncedShowTooltip, false);\n    window.addEventListener('mouseout', this.debouncedHideTooltip, false);\n  },\n\n  componentWillUnmount: function componentWillUnmount() {\n    window.removeEventListener('mouseout', this.debouncedHideTooltip, false);\n    window.removeEventListener('mouseover', this.debouncedShowTooltip, false);\n  },\n\n  render: function render() {\n    if (!this.state.element) {\n      return null;\n    }\n\n    var content = this.inspectElement(this.props.corpus, this.state.element);\n\n    if (!content) {\n      return null;\n    }\n\n    return (\n      React.createElement(Tooltip, { target: this.state.element },\n        content));\n\n\n  },\n\n  showTooltip: function showTooltip(e) {\n    if (isApplicable(this.getContainerDOMNode(), e.target)) {\n      if (this.state.element !== e.target) {\n        this.setState({ element: e.target });\n      }\n    } else\n    if (e.target === findDOMNode(this)) {\n      return;\n    } else\n    if (this.state.element) {\n      this.setState({ element: null });\n    }\n  },\n\n  hideTooltip: function hideTooltip(e) {\n    if (e.target === this.state.element) {\n      this.setState({ element: null });\n    }\n  },\n\n  getContainerDOMNode: function getContainerDOMNode() {\n    return this.props.inSinglePageMode ?\n    document.querySelector('.single-page-layout__content') :\n    document.querySelector('.two-column-layout__right') ||\n    document.querySelector('.root__screen');\n\n  },\n\n  inspectElement: function inspectElement(corpus, el) {\n    var href = decodeURIComponent(el.href.replace(location.origin, ''));\n    var documentNode = corpus.getByURI(href);\n\n    if (documentNode) {\n      var context = {\n        documentNode: documentNode,\n        namespaceNode: corpus.getNamespaceOfDocument(documentNode) };\n\n\n      if (this.props.isOutletOccupied({ name: 'Inspector', elementProps: context })) {\n        return React.createElement(Outlet, { name: 'Inspector', elementProps: context });\n      }\n    }\n  } });\n\n\n\nfunction isApplicable(containerNode, node) {\n  return (\n    node.tagName === 'A' &&\n    domContains(containerNode, node));\n\n}\n\nmodule.exports = OutletRenderer(Inspector);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/ui/components/Inspector.js\n ** module id = 209\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/ui/components/Inspector.js?");

/***/ },

/***/ 210:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";var React = __webpack_require__(1);var _React$PropTypes =\nReact.PropTypes,instanceOf = _React$PropTypes.instanceOf,node = _React$PropTypes.node;\n\nvar InspectorTooltip = React.createClass({ displayName: \"InspectorTooltip\",\n  propTypes: {\n    target: instanceOf(window.Element).isRequired,\n    children: node.isRequired },\n\n\n  getInitialState: function getInitialState() {\n    return {\n      top: 0,\n      left: 0 };\n\n  },\n\n  componentDidMount: function componentDidMount() {\n    this.computePositions(this.props.target);\n  },\n\n  componentWillUpdate: function componentWillUpdate(nextProps) {\n    if (nextProps.target !== this.props.target) {\n      this.computePositions(nextProps.target);\n    }\n  },\n\n  render: function render() {\n    return (\n      React.createElement(\"div\", {\n        style: this.state,\n        className: \"tooltip\",\n        children: this.props.children }));\n\n\n  },\n\n  computePositions: function computePositions(targetNode) {\n    var bbox = targetNode.getBoundingClientRect();var\n    top = bbox.top,left = bbox.left;\n    top += bbox.height;\n\n    if (top !== this.state.top || left !== this.state.left) {\n      this.setState({ top: top, left: left });\n    }\n  } });\n\n\nmodule.exports = InspectorTooltip;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/ui/components/InspectorTooltip.js\n ** module id = 210\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/ui/components/InspectorTooltip.js?");

/***/ },

/***/ 211:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';var React = __webpack_require__(1);\nvar classSet = __webpack_require__(198);\nvar Banner = __webpack_require__(212);\nvar LayoutScreen = __webpack_require__(217);\nvar scrollToTop = __webpack_require__(228);var _React$PropTypes =\n\nReact.PropTypes,node = _React$PropTypes.node,shape = _React$PropTypes.shape,string = _React$PropTypes.string,arrayOf = _React$PropTypes.arrayOf,array = _React$PropTypes.array,object = _React$PropTypes.object,bool = _React$PropTypes.bool;\nvar Link = shape({\n  text: string,\n  href: string,\n  links: array });\n\n\nvar Layout = React.createClass({ displayName: 'Layout',\n  contextTypes: {\n    appState: object.isRequired },\n\n\n  propTypes: {\n    children: node,\n    pathname: string.isRequired,\n\n    template: shape({\n      regions: array,\n      hasSidebarElements: bool }).\n    isRequired,\n\n    scope: shape({\n      documentNode: object,\n      documentEntityNode: object,\n      namespaceNode: object }),\n\n\n    banner: bool,\n    fixedSidbar: bool,\n    bannerLinks: arrayOf(Link) },\n\n\n  getDefaultProps: function getDefaultProps() {\n    return {\n      banner: true,\n      fixedSidbar: true,\n      bannerLinks: [] };\n\n  },\n\n  componentWillUpdate: function componentWillUpdate(nextProps) {\n    if (!this.context.appState.inSinglePageMode()) {\n      if (nextProps.scope.documentNode !== this.props.scope.documentNode) {\n        scrollToTop();\n      }\n    }\n  },\n\n  render: function render() {var\n    template = this.props.template;\n    var config = this.props;\n    var className = classSet({\n      'root': true,\n      'root--with-multi-page-layout': true,\n      'root--with-fixed-sidebar': config.fixedSidbar,\n      'root--with-two-column-layout': template.hasSidebarElements,\n      'root--with-banner': config.banner,\n      'root--without-banner': !config.banner });\n\n\n    return (\n      React.createElement('div', { className: className },\n        config.banner &&\n        React.createElement(Banner, {\n          links: config.bannerLinks || [],\n          currentPath: this.props.pathname }),\n\n\n\n        React.createElement(LayoutScreen, template)));\n\n\n  } });\n\n\nmodule.exports = Layout;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/ui/components/Layout.js\n ** module id = 211\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/ui/components/Layout.js?");

/***/ },

/***/ 212:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";var _extends = Object.assign || function (target) {for (var i = 1; i < arguments.length; i++) {var source = arguments[i];for (var key in source) {if (Object.prototype.hasOwnProperty.call(source, key)) {target[key] = source[key];}}}return target;};var React = __webpack_require__(1);\nvar Link = __webpack_require__(197);var _require =\n__webpack_require__(180),Outlet = _require.Outlet;\nvar Icon = __webpack_require__(213);\nvar ConfigReceiver = __webpack_require__(214);\nvar DocumentURI = __webpack_require__(208);\nvar BannerItem = __webpack_require__(215);\nvar BannerMenu = __webpack_require__(216);var _React$PropTypes =\nReact.PropTypes,string = _React$PropTypes.string,any = _React$PropTypes.any,arrayOf = _React$PropTypes.arrayOf,object = _React$PropTypes.object;var\nPropTypes = React.PropTypes;\n\nvar ConfigType = {\n  motto: PropTypes.string,\n  title: PropTypes.string,\n  spotlight: PropTypes.bool,\n  showSettingsLinkInBanner: PropTypes.bool };\n\n\nvar Banner = React.createClass({ displayName: \"Banner\",\n  statics: { BannerItem: BannerItem },\n\n  propTypes: {\n    children: any,\n    currentPath: string,\n    links: arrayOf(object),\n    config: PropTypes.shape(ConfigType) },\n\n\n  contextTypes: {\n    appState: PropTypes.object.isRequired,\n    documentURI: PropTypes.instanceOf(DocumentURI).isRequired },\n\n\n  render: function render() {var\n    config = this.props.config;\n\n    return (\n      React.createElement(\"div\", { className: \"banner-wrapper\" },\n        React.createElement(\"header\", { className: \"banner\" },\n          React.createElement(\"h1\", { className: \"banner__logo\" },\n            React.createElement(Link, { href: \"/index.html\" },\n              config.title || 'megadoc'),\n\n\n            ' ',\n\n            config.motto && config.motto.length > 0 &&\n            React.createElement(\"span\", { className: \"banner__motto\" },\n              config.motto),\n\n\n\n            this.props.children),\n\n\n          React.createElement(\"nav\", { className: \"banner__navigation\" },\n            config.spotlight &&\n            React.createElement(BannerItem, {\n                key: \"spotlight\",\n                onClick: this.toggleSpotlight,\n                title: \"Quick-Jump (Ctrl+K or CMD+K)\" },\n\n              React.createElement(Icon, { className: \"icon-search\" })),\n\n\n\n            React.createElement(Outlet, {\n                name: \"MultiPageLayout::Banner\",\n                alwaysRenderChildren: true,\n                tagName: \"span\",\n                fnRenderElement: function fnRenderElement(key, props, Type) {return (\n                    React.createElement(BannerItem, { key: key },\n                      React.createElement(Type, props)));} },\n\n\n\n              config.showSettingsLinkInBanner &&\n              React.createElement(BannerItem, { key: \"settings\" },\n                React.createElement(Link, { href: \"/settings.html\" },\n                  React.createElement(Icon, { className: \"icon-cog\" }))),\n\n\n\n\n              this.props.links.map(this.renderLink))))));\n\n\n\n\n\n  },\n\n  renderLink: function renderLink(link) {\n    if (link.links) {\n      return (\n        React.createElement(BannerItem, { key: link.text },\n          React.createElement(BannerMenu, _extends({ currentPath: this.props.currentPath }, link))));\n\n\n    }\n\n    return (\n      React.createElement(BannerItem, { key: link.text },\n        React.createElement(Link, { href: this.context.documentURI.withExtension(link.href) }, link.text)));\n\n\n  },\n\n  toggleSpotlight: function toggleSpotlight() {\n    if (this.context.appState.isSpotlightOpen()) {\n      this.context.appState.closeSpotlight();\n    } else\n    {\n      this.context.appState.openSpotlight();\n    }\n  } });\n\n\nmodule.exports = ConfigReceiver(Banner, ConfigType);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/ui/components/Layout__Banner.js\n ** module id = 212\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/ui/components/Layout__Banner.js?");

/***/ },

/***/ 215:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";var React = __webpack_require__(1);var _React$PropTypes =\nReact.PropTypes,node = _React$PropTypes.node,func = _React$PropTypes.func,string = _React$PropTypes.string;\n\nvar BannerItem = React.createClass({ displayName: \"BannerItem\",\n  propTypes: {\n    children: node,\n    onClick: func,\n    title: string },\n\n\n  render: function render() {\n    return (\n      React.createElement(\"div\", {\n        className: \"banner__navigation-item\",\n        children: this.props.children,\n        onClick: this.props.onClick,\n        title: this.props.title }));\n\n\n  } });\n\n\nmodule.exports = BannerItem;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/ui/components/Layout__BannerItem.js\n ** module id = 215\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/ui/components/Layout__BannerItem.js?");

/***/ },

/***/ 216:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";var React = __webpack_require__(1);\nvar Link = __webpack_require__(197);\nvar Icon = __webpack_require__(213);\nvar classSet = __webpack_require__(198);\nvar DocumentURI = __webpack_require__(208);var _React$PropTypes =\nReact.PropTypes,string = _React$PropTypes.string,oneOf = _React$PropTypes.oneOf,arrayOf = _React$PropTypes.arrayOf,shape = _React$PropTypes.shape;\n\nvar BannerMenu = React.createClass({ displayName: \"BannerMenu\",\n  propTypes: {\n    currentPath: string,\n    openStrategy: oneOf(['hover', 'click']),\n    text: string.isRequired,\n    href: string,\n    links: arrayOf(shape({\n      text: string.isRequired,\n      href: string.isRequired })).\n    isRequired },\n\n\n  contextTypes: {\n    documentURI: React.PropTypes.instanceOf(DocumentURI).isRequired },\n\n\n  getDefaultProps: function getDefaultProps() {\n    return {\n      openStrategy: 'hover' };\n\n  },\n\n  getInitialState: function getInitialState() {\n    return {\n      clicked: false,\n      hovering: false };\n\n  },\n\n  componentWillUpdate: function componentWillUpdate(nextProps) {\n    if (nextProps.currentPath !== this.props.currentPath && this.state.clicked) {\n      this.close();\n    }\n  },\n\n  render: function render() {var _this = this;\n    var isOpen = this.props.openStrategy === 'click' ?\n    this.state.clicked :\n    this.state.hovering;\n\n    var isActive = this.props.links.some(function (x) {return _this.props.currentPath === x.href;});\n    var icon = React.createElement(Icon, { className: \"icon-arrow-down\" });\n\n    return (\n      React.createElement(\"div\", {\n          onMouseEnter: this.trackCursorOn,\n          onMouseLeave: this.trackCursorOff,\n          className: classSet(\"banner__menu\", {\n            \"banner__menu--open\": isOpen,\n            \"banner__menu--active\": isActive }) },\n\n\n        React.createElement(\"span\", {\n            className: \"banner__menu-title\",\n            onClick: this.toggle },\n\n          this.props.href ?\n          React.createElement(Link, {\n              href: this.context.documentURI.withExtension(this.props.href),\n              active: isActive },\n\n            this.props.text, \" \", icon) :\n\n\n          React.createElement(\"span\", null, this.props.text, \" \", icon)),\n\n\n\n\n        isOpen &&\n        React.createElement(\"ul\", { className: \"banner__menu-list\" },\n          this.props.links.map(this.renderLink))));\n\n\n\n\n  },\n\n  renderLink: function renderLink(link) {\n    return (\n      React.createElement(\"li\", { key: link.href + link.text, className: \"banner__menu-list-item\" },\n        React.createElement(Link, { href: this.context.documentURI.withExtension(link.href) }, link.text)));\n\n\n  },\n\n  trackCursorOn: function trackCursorOn() {\n    if (!this.state.hovering) {\n      this.setState({ hovering: true });\n    }\n  },\n\n  trackCursorOff: function trackCursorOff() {\n    if (this.state.hovering) {\n      this.setState({ hovering: false });\n    }\n  },\n\n  toggle: function toggle() {\n    this.setState({ clicked: !this.state.clicked });\n  },\n\n  close: function close() {\n    this.setState({ clicked: false });\n  } });\n\n\nmodule.exports = BannerMenu;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/ui/components/Layout__BannerMenu.js\n ** module id = 216\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/ui/components/Layout__BannerMenu.js?");

/***/ },

/***/ 217:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';var React = __webpack_require__(1);\nvar TwoColumnLayout = __webpack_require__(218);\nvar NotFound = __webpack_require__(222);\nvar Document = __webpack_require__(223);\nvar ErrorMessage = __webpack_require__(224);\nvar Footer = __webpack_require__(225);\nvar Sticky = __webpack_require__(227);\nvar ConfigReceiver = __webpack_require__(214);var _require =\n__webpack_require__(180),OutletRenderer = _require.OutletRenderer,Outlet = _require.Outlet;var\nPropTypes = React.PropTypes;\n\nvar ConfigType = {\n  collapsibleSidebar: PropTypes.bool,\n  footer: PropTypes.string,\n  resizableSidebar: PropTypes.bool };\n\n\nvar LayoutScreen = React.createClass({ displayName: 'LayoutScreen',\n  propTypes: {\n    hasSidebarElements: PropTypes.bool,\n    isOutletDefined: PropTypes.func,\n    regions: PropTypes.arrayOf(PropTypes.shape({\n      name: PropTypes.string.isRequired,\n      options: PropTypes.object,\n\n      outlets: PropTypes.arrayOf(PropTypes.shape({\n        name: PropTypes.string,\n        options: PropTypes.object,\n        using: PropTypes.string,\n        scope: PropTypes.shape({\n          documentEntityNode: PropTypes.object,\n          documentNode: PropTypes.object,\n          namespaceNode: PropTypes.object }) })) })).\n\n\n    isRequired,\n\n    config: PropTypes.shape(ConfigType) },\n\n\n  render: function render() {\n    return (\n      React.createElement('div', { className: 'root__screen' },\n        this.props.hasSidebarElements ?\n        this.renderTwoColumnLayout() :\n        this.renderSingleColumnLayout()));\n\n\n\n  },\n\n  renderTwoColumnLayout: function renderTwoColumnLayout() {\n    var navBar = this.renderNavBar();var\n    config = this.props.config;\n\n    return (\n      React.createElement(TwoColumnLayout, {\n          resizable: config.resizableSidebar,\n          collapsible: config.collapsibleSidebar },\n\n        React.createElement(TwoColumnLayout.LeftColumn, null,\n          React.createElement('div', null,\n            this.renderRegion('Layout::Sidebar'))),\n\n\n\n        React.createElement(TwoColumnLayout.RightColumn, null,\n          this.renderContent()),\n\n\n        navBar &&\n        React.createElement(TwoColumnLayout.NavColumn, null,\n          navBar)));\n\n\n\n\n  },\n\n  renderSingleColumnLayout: function renderSingleColumnLayout() {\n    return this.renderContent();\n  },\n\n  renderContent: function renderContent() {\n    var ContentTag = this.getOutletTag('Layout::Content');\n\n    return (\n      React.createElement('div', null,\n        React.createElement(ContentTag, null,\n          this.renderRegion('Layout::Content') || React.createElement(NotFound, null)),\n\n\n        React.createElement(Footer, null, this.props.config.footer)));\n\n\n  },\n\n  renderNavBar: function renderNavBar() {\n    var contents = this.renderRegion('Layout::NavBar');\n\n    if (!contents) {\n      return null;\n    }\n\n    var ContentTag = this.getOutletTag('Layout::NavBar');\n\n    return (\n      React.createElement(Sticky, null,\n        React.createElement(ContentTag, null,\n          React.createElement('p', null, 'Contents'),\n\n          this.renderRegion('Layout::NavBar'))));\n\n\n\n  },\n\n  renderRegion: function renderRegion(regionName) {var _this = this;\n    var region = this.props.regions.filter(function (x) {return x.name === regionName;})[0];\n\n    if (!region || !region.outlets) {\n      return null;\n    }\n\n\n    return region.outlets.map(function (x, i) {var\n      scope = x.scope;\n      var key = x.name + '__' + i;\n\n      if (!_this.props.isOutletDefined(x.name)) {\n        return (\n          React.createElement(ErrorMessage, { key: key },\n            React.createElement('p', null, 'Outlet \"',\n              x.name, '\" has not been defined! This is most likely a configuration error. Please verify the outlet name is correct.')));\n\n\n\n\n      } else\n      if (!scope) {\n        return (\n          React.createElement(ErrorMessage, { key: key },\n            React.createElement('p', null, 'No document was found with the UID \"',\n              x.using, '\" to be inserted into the outlet \"',\n              x.name, '\" of the region \"', region.name, '\". This is most likely a configuration error.')));\n\n\n\n\n      }\n\n      return (\n        React.createElement(Outlet, {\n          key: key,\n          name: x.name,\n          options: x.options,\n          elementProps: scope }));\n\n\n    }).filter(function (x) {return !!x;});\n  },\n\n  getOutletTag: function getOutletTag(regionName) {\n    var spec = this.props.regions.filter(function (x) {return x.name === regionName;})[0];\n\n    if (spec) {\n      if (spec.options && spec.options.framed) {\n        return Document;\n      }\n    }\n\n    return 'div';\n  } });\n\n\nmodule.exports = OutletRenderer(ConfigReceiver(LayoutScreen, ConfigType));\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/ui/components/Layout__Screen.js\n ** module id = 217\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/ui/components/Layout__Screen.js?");

/***/ },

/***/ 229:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';var React = __webpack_require__(1);\nvar Router = __webpack_require__(230);var\nfilter = Array.prototype.filter;\n\nvar ScrollSpy = React.createClass({ displayName: 'ScrollSpy',\n  getDefaultProps: function getDefaultProps() {\n    return {\n      query: {},\n      params: {} };\n\n  },\n\n  componentDidMount: function componentDidMount() {\n    window.addEventListener('scroll', focusClosestHeading, false);\n  },\n\n  shouldComponentUpdate: function shouldComponentUpdate() {\n    return false;\n  },\n\n  componentWillUnmount: function componentWillUnmount() {\n    window.removeEventListener('scroll', focusClosestHeading, false);\n  },\n\n  render: function render() {\n    return null;\n  } });\n\n\nmodule.exports = ScrollSpy;\n\nfunction focusClosestHeading() {\n  var nodes = filter.call(document.querySelectorAll('[id]'), function (node) {\n    return node.tagName.match(/^H\\d/);\n  }).map(function (node) {\n    return {\n      node: node,\n      box: node.getBoundingClientRect() };\n\n  });\n\n  var target = void 0,min = void 0;\n\n  nodes.forEach(function (item) {\n    var top = Math.abs(item.box.top);\n\n    if (min === undefined) {\n      min = top;\n      target = item;\n    } else\n    if (top < min) {\n      min = top;\n      target = item;\n    }\n  });\n\n  if (target) {var\n    id = target.node.id;\n    var newHash = '#' + id;\n\n    if (window.location.hash !== newHash) {\n      // LOLOL\n      //\n      // no but seriously, we need to do this so that when we change the hash\n      // manually, the browser don't jump!\n      target.node.id = null;\n\n      // can't use history.replaceState because it's not allowed on file://\n      window.location.hash = newHash;\n\n      target.node.id = id;\n\n      Router.refresh();\n    }\n  }\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/ui/components/ScrollSpy.js\n ** module id = 229\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/ui/components/ScrollSpy.js?");

/***/ },

/***/ 231:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';var CorpusAPI = __webpack_require__(232);\nvar invariant = __webpack_require__(174);\nvar LayoutEngine = __webpack_require__(233);\n\nfunction DocumentResolver(_ref) {var config = _ref.config,corpus = _ref.corpus,documentURI = _ref.documentURI;\n  this.corpus = corpus;\n  this.config = config;\n  this.documentURI = documentURI;\n}\n\nDocumentResolver.prototype.resolveFromLocation = function (location) {var\n  config = this.config,corpus = this.corpus;\n  var node = void 0;\n\n  invariant(typeof location.pathname === 'string',\n  \"Location @pathname must be present.\");\n\n  invariant(typeof location.origin === 'string',\n  \"Location @origin must be present.\");\n\n  invariant(typeof location.protocol === 'string',\n  \"Location @protocol must be present.\");\n\n  invariant(typeof location.hash === 'string',\n  \"Location @hash must be present.\");\n\n\n  var href = this.getProtocolAgnosticPathName(location);\n\n  if (config && config.layoutOptions) {\n    var overriddenDocumentLink = LayoutEngine.getDocumentOverride(href, config.layoutOptions);\n\n    if (overriddenDocumentLink) {\n      node = getByUIDOrURI(corpus, overriddenDocumentLink);\n\n      if (!node) {\n        console.warn(\n        \"A document '%s' specified as an override for the url '%s' could \" +\n        \"not be found. This is most likely a configuration error.\",\n        overriddenDocumentLink, href);\n\n      }\n    }\n  }\n\n  if (!node) {\n    node = corpus.getByURI(href);\n  }\n\n  if (node) {\n    return buildDocumentContext(resolveRedirect(this, node));\n  } else\n  {\n    // try to resolve index node\n    var indexPathname = location.pathname + 'index';\n    var indexHref = this.documentURI.withExtension(indexPathname) + location.hash;\n    var indexNode = corpus.getByURI(indexHref);\n\n    if (indexNode) {\n      return buildDocumentContext(resolveRedirect(this, indexNode));\n    } else\n    {\n      if (this.config.redirect[location.pathname]) {\n        return this.resolveFromLocation(Object.assign({}, location, {\n          pathname: this.config.redirect[location.pathname] }));\n\n      } else\n      {\n        console.warn(\"Unable to find a document at the URI '%s' (from '%s')\", href, location.pathname);\n        return null;\n      }\n    }\n  }\n};\n\nDocumentResolver.prototype.getProtocolAgnosticPathName = function (location) {\n  return this.documentURI.normalize(\n  this.documentURI.withExtension(location.pathname)) +\n  location.hash;\n};\n\nfunction resolveRedirect(resolver, contextNode) {\n  if (contextNode && contextNode.meta && contextNode.meta.redirect) {\n    var targetNode = getByUIDOrURI(resolver.corpus, contextNode.meta.redirect);\n\n    if (targetNode) {\n      return targetNode;\n    } else\n    {\n      console.warn(\"Unable to find the redirect document target at '%s' (from '%s')\", targetNode.meta.redirect, contextNode.uid);\n\n      return null;\n    }\n  } else\n  {\n    return contextNode;\n  }\n}\n\nfunction getByUIDOrURI(corpus, link) {\n  return corpus.get(link) || corpus.getByURI(link);\n}\n\nfunction buildDocumentContext(node) {\n  var ctx = {};\n\n  if (node.type === 'DocumentEntity') {\n    ctx.documentEntityNode = node;\n    ctx.documentNode = node.parentNode;\n    ctx.namespaceNode = CorpusAPI.getNamespaceOfNode(node);\n  } else\n  if (node.type === 'Document') {\n    ctx.documentNode = node;\n    ctx.namespaceNode = CorpusAPI.getNamespaceOfNode(node);\n  } else\n  if (node.type === 'Namespace') {\n    ctx.namespaceNode = node;\n  }\n\n  return ctx;\n}\n\nmodule.exports = DocumentResolver;\nmodule.exports.buildDocumentContext = buildDocumentContext;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/ui/DocumentResolver.js\n ** module id = 231\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/ui/DocumentResolver.js?");

/***/ },

/***/ 233:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';var invariant = __webpack_require__(174);\n\n/**\n                                                          * @module LayoutEngine\n                                                          *\n                                                          * @typedef {LayoutOverride}\n                                                          *\n                                                          * A layout override configuration object. This object describes how to render\n                                                          * a certain page. By default, megadoc will compute a preferred layout based on\n                                                          * the type of document that is being rendered.\n                                                          *\n                                                          * @property {Object} match\n                                                          *           The parameters that control when this configuration applies.\n                                                          *\n                                                          * @property {url|uid|type} match.by\n                                                          *           What we should match on.\n                                                          *\n                                                          * @property {String|Array.<String>} match.on\n                                                          *           The value for matching:\n                                                          *\n                                                          *           - If @match.by was set to `url`, this would be the URL(s) of the\n                                                          *           pages.\n                                                          *           - If @match.by was set to `uid`, this would be the corpus UIDs\n                                                          *           of the documents.\n                                                          *           - If @match.by was set to `type`, this would be the corpus ADT\n                                                          *           node type. See [[T]].\n                                                          *\n                                                          * @property {Array.<LayoutRegion>} regions\n                                                          *\n                                                          * @typedef {LayoutRegion}\n                                                          *\n                                                          * A configuration object for a specific layout region.\n                                                          *\n                                                          * @property {String} name\n                                                          *           The name of the region. See [[Layout]] for the regions it defines.\n                                                          *\n                                                          * @property {Object?} options\n                                                          *           Options to customize how the region looks like. Refer to each\n                                                          *           region's documentation to know what options it supports.\n                                                          *\n                                                          * @property {Array.<LayoutRegionOutlet>} outlets\n                                                          *           The outlets to fill the region with.\n                                                          *\n                                                          * @typedef {LayoutRegionOutlet}\n                                                          *\n                                                          * @property {String} name\n                                                          * @property {Object?} options\n                                                          */\n\n/**\n                                                              * @param {String} href\n                                                              * @param {Object} layoutConfig\n                                                              * @param {Array.<LayoutOverride>} layoutConfig.customLayouts\n                                                              *\n                                                              * @return {String}\n                                                              *         The UID of the document to use for the given location.\n                                                              */\nexports.getDocumentOverride = function (pathname, layoutConfig) {\n  if (layoutConfig.customLayouts) {\n    var layoutOverride = getLayoutOverride({ pathname: pathname }, layoutConfig.customLayouts);\n\n    if (layoutOverride && layoutOverride.using) {\n      return layoutOverride.using;\n    }\n  }\n};\n\nfunction getLayoutOverride(scope, layouts) {\n  if (!layouts) {\n    return null;\n  }\n\n  return layouts.filter(function (x) {\n    invariant(x.hasOwnProperty('match'),\n    \"A custom layout must have a @match property defined!\");\n\n\n    return match(x, scope);\n  })[0];\n}\n\nfunction getRegionsForDocument(scope, layouts) {\n  var layoutOverride = getLayoutOverride(scope, layouts);\n\n  if (layoutOverride) {\n    return layoutOverride.regions;\n  }\n}\n\nfunction arrayWrap(x) {\n  return Array.isArray(x) ? x : [].concat(x || []);\n}\n\nfunction match(entry, _ref) {var documentNode = _ref.documentNode,namespaceNode = _ref.namespaceNode,pathname = _ref.pathname;\n  var matchBy = entry.match.by;\n  var matchOn = arrayWrap(entry.match.on);\n\n  return (\n\n    matchBy === 'type' && (\n\n    documentNode && matchOn.indexOf(documentNode.type) > -1 ||\n    namespaceNode && matchOn.indexOf(namespaceNode.type) > -1) ||\n\n\n\n    documentNode &&\n    matchBy === 'uid' &&\n    matchOn.indexOf(documentNode.uid) > -1 ||\n\n\n    matchBy === 'url' &&\n    matchByURL(matchOn, pathname) ||\n\n\n    matchBy === 'namespace' &&\n    namespaceNode &&\n    matchOn.indexOf(namespaceNode.uid) > -1);\n\n\n};\n\nfunction matchByURL(matchOn, pathname) {\n  var pathWithoutHash = pathname.split('#')[0];\n\n  return matchOn.some(function (pattern) {\n    if (pattern === '*') {\n      return true;\n    }\n\n    return pathWithoutHash.match(pattern);\n  });\n}\n\nexports.match = match;\nexports.getRegionsForDocument = getRegionsForDocument;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/ui/LayoutEngine.js\n ** module id = 233\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/ui/LayoutEngine.js?");

/***/ },

/***/ 234:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';var DocumentResolver = __webpack_require__(231);\nvar LayoutEngine = __webpack_require__(233);var _require =\n__webpack_require__(187),assign = _require.assign;var\ngetRegionsForDocument = LayoutEngine.getRegionsForDocument;\n\nfunction TemplateRealizer(corpus, config) {\n  var layoutConfig = config.layoutOptions;\n\n  return function (globalScope, pathname) {\n    var regions = Regions(globalScope, {\n      // we'll need the pathname for filtering outlets:\n      pathname: pathname,\n      customLayouts: layoutConfig.customLayouts });\n\n\n    return {\n      regions: regions,\n      hasSidebarElements: regions.some(function (x) {return x.name === 'Layout::Sidebar';}) };\n\n  };\n\n  function Regions(globalScope, params) {\n    var globalScopeWithPathname = assign({}, globalScope, {\n      pathname: params.pathname });\n\n\n    var regions =\n    // custom regions from a template:\n    getRegionsForDocument(globalScopeWithPathname, params.customLayouts) ||\n    // default regions from the plugin template:\n    getDefaultDocumentRegions(globalScopeWithPathname) ||\n    getDefaultGlobalRegions();\n\n\n    return regions.map(function (region) {\n      return RegionWithActiveOutlets(region, globalScope, globalScopeWithPathname);\n    });\n  }\n\n  function RegionWithActiveOutlets(region, globalScope, globalScopeWithPathname) {\n    if (!region.outlets) {\n      return region;\n    }\n\n    return assign({}, region, {\n      outlets: region.outlets.\n      filter(function (x) {\n        return !x.match || LayoutEngine.match(x, globalScopeWithPathname);\n      }).\n      map(function (x) {\n        return assign({}, x, { scope: getOutletScope(x, globalScope) });\n      }) });\n\n  }\n\n  function getDefaultDocumentRegions(scopeWithPathname) {var\n    namespaceNode = scopeWithPathname.namespaceNode;\n\n    if (namespaceNode && namespaceNode.meta.defaultLayouts) {\n      return getRegionsForDocument(scopeWithPathname, namespaceNode.meta.defaultLayouts);\n    }\n  }\n\n  function getDefaultGlobalRegions() {\n    return [\n    {\n      name: 'Layout::Content',\n      outlets: null }];\n\n\n  }\n\n  function getOutletScope(outlet, parentScope) {\n    var customScope = void 0;\n\n    if (outlet.using) {\n      var node = corpus.get(outlet.using);\n\n      if (node) {\n        customScope = DocumentResolver.buildDocumentContext(node);\n      }\n    }\n\n    if (outlet.injectionStrategy === 'fixate') {\n      return customScope || parentScope;\n    } else\n    {\n      return assign({}, parentScope, customScope);\n    }\n  }\n}\n\nmodule.exports = TemplateRealizer;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/ui/LayoutTemplate.js\n ** module id = 234\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/ui/LayoutTemplate.js?");

/***/ },

/***/ 235:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';var _require$PropTypes = __webpack_require__(1).PropTypes,shape = _require$PropTypes.shape,string = _require$PropTypes.string,func = _require$PropTypes.func,oneOf = _require$PropTypes.oneOf;\n\nmodule.exports = shape({\n  pathname: string,\n  origin: string,\n  protocol: oneOf(['file:', 'http:', 'https:']),\n  hash: string,\n  replace: func });\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/ui/shared/schemas/Location.js\n ** module id = 235\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/ui/shared/schemas/Location.js?");

/***/ },

/***/ 236:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';var React = __webpack_require__(1);\nvar SidebarHeader = __webpack_require__(237);var _React$PropTypes =\nReact.PropTypes,shape = _React$PropTypes.shape,string = _React$PropTypes.string;\n\nvar SidebarHeaderOutlet = React.createClass({ displayName: 'SidebarHeaderOutlet',\n  propTypes: {\n    $outletOptions: shape({\n      text: string.isRequired }) },\n\n\n\n  render: function render() {\n    return (\n      React.createElement(SidebarHeader, null,\n        this.props.$outletOptions.text));\n\n\n  } });\n\n\nmodule.exports = function (megadoc) {\n  megadoc.outlets.add('Layout::SidebarHeader', {\n    key: 'xxx',\n    component: SidebarHeaderOutlet });\n\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/ui/outlets/SidebarHeaderOutlet.js\n ** module id = 236\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/ui/outlets/SidebarHeaderOutlet.js?");

/***/ },

/***/ 238:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';var React = __webpack_require__(1);var _React$PropTypes =\nReact.PropTypes,shape = _React$PropTypes.shape,string = _React$PropTypes.string;\nvar resolvePathname = __webpack_require__(200);\n\nvar ImageOutlet = React.createClass({ displayName: 'ImageOutlet',\n  contextTypes: {\n    location: shape({\n      pathname: string }) },\n\n\n\n  propTypes: {\n    $outletOptions: shape({\n      src: string.isRequired }).\n    isRequired },\n\n\n  render: function render() {\n    return (\n      React.createElement('img', { src: resolvePathname(this.props.$outletOptions.src, this.context.location.pathname) }));\n\n  } });\n\n\nmodule.exports = function (megadoc) {\n  megadoc.outlets.add('Image', {\n    key: 'Image',\n    component: ImageOutlet });\n\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/ui/outlets/ImageOutlet.js\n ** module id = 238\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/ui/outlets/ImageOutlet.js?");

/***/ },

/***/ 239:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';var React = __webpack_require__(1);var _React$PropTypes =\nReact.PropTypes,shape = _React$PropTypes.shape,string = _React$PropTypes.string;\nvar Link = __webpack_require__(197);\n\nvar LinkOutlet = React.createClass({ displayName: 'LinkOutlet',\n  contextTypes: {\n    location: shape({\n      pathname: string }) },\n\n\n\n  propTypes: {\n    $outletOptions: shape({\n      href: string.isRequired,\n      text: string.isRequired,\n      title: string }).\n    isRequired },\n\n\n  render: function render() {\n    var props = this.props.$outletOptions;\n\n    return (\n      React.createElement(Link, { href: props.href, title: props.title, children: props.text }));\n\n  } });\n\n\nmodule.exports = function (megadoc) {\n  megadoc.outlets.add('Link', {\n    key: 'Link',\n    component: LinkOutlet });\n\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/ui/outlets/LinkOutlet.js\n ** module id = 239\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/ui/outlets/LinkOutlet.js?");

/***/ },

/***/ 262:
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';var React = __webpack_require__(1);var _React$PropTypes =\nReact.PropTypes,shape = _React$PropTypes.shape,string = _React$PropTypes.string;\n\nvar TextOutlet = React.createClass({ displayName: 'TextOutlet',\n  propTypes: {\n    $outletOptions: shape({\n      tagName: string,\n      className: string,\n      text: string.isRequired,\n      title: string }).\n    isRequired },\n\n\n  render: function render() {\n    var props = this.props.$outletOptions;\n    var HTMLTag = props.tagName || 'div';\n\n    return (\n      React.createElement(HTMLTag, { className: props.className, title: props.title, children: props.text }));\n\n  } });\n\n\nmodule.exports = function (megadoc) {\n  megadoc.outlets.add('Text', {\n    key: 'Text',\n    component: TextOutlet });\n\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./packages/megadoc-html-serializer/ui/outlets/TextOutlet.js\n ** module id = 262\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./packages/megadoc-html-serializer/ui/outlets/TextOutlet.js?");

/***/ }

})
});
;